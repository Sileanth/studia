
open Formula

module type Theory = sig 
  type axiom 
  val axiom : axiom -> formula 
end

module Make(T : Theory) = struct
  module AxiomLogic = Logic.Make(T)
  open AxiomLogic
  open Formula
  
  module StringMap = Map.Make(String)
  
  type assump = (string * theorem) list
  type free_binding = (var StringMap.t *  string VarMap.t )
  
  type node = formula * assump * free_binding
  type goal = formula * assump * free_binding

  type all_elim_info = term
  type ex_intro_info = var * term * formula
  type equiv_info = formula
  type ren_info = var * var

  module ProofTree : sig 
    type proof_tree 
    type view = 
      | VGoal of goal
      | VLemat of theorem
      | VAndI  of node * proof_tree * proof_tree
      | VAndE1 of node * proof_tree
      | VAndE2 of node * proof_tree
      | VImpE  of node * proof_tree * proof_tree
      | VImpI  of node * proof_tree
      | VBotE  of node * proof_tree
      | VAllI  of node * proof_tree
      | VAllE  of node * proof_tree * all_elim_info 
      | VExI   of node * proof_tree * ex_intro_info 
      | VExE   of node * proof_tree * proof_tree
      | VOrI1  of node * proof_tree
      | VOrI2  of node * proof_tree
      | VOrE   of node * proof_tree * proof_tree * proof_tree
      | VEquiv of node * proof_tree * equiv_info 
      | VRen   of node * proof_tree * ren_info

 
    val view : proof_tree -> view  

    val goal : goal -> proof_tree
    val lemat : theorem -> proof_tree
    val andI : node -> proof_tree -> proof_tree -> proof_tree
    val andE1 : node -> proof_tree -> proof_tree
    val andE2 : node -> proof_tree -> proof_tree
    val impE : node -> proof_tree -> proof_tree -> proof_tree
    val impI : node -> proof_tree -> proof_tree
    val botE : node -> proof_tree -> proof_tree
    val allI : node -> proof_tree -> proof_tree
    val allE : all_elim_info -> node -> proof_tree -> proof_tree
    val exI : ex_intro_info -> node -> proof_tree -> proof_tree
    val exE : node -> proof_tree -> proof_tree -> proof_tree
    val orI1 : node -> proof_tree -> proof_tree
    val orI2 : node -> proof_tree -> proof_tree
    val orE : node -> proof_tree -> proof_tree -> proof_tree -> proof_tree
    val equiv_b : node -> equiv_info -> proof_tree -> proof_tree
    val ren_b : ren_info -> node -> proof_tree -> proof_tree
  end = struct  
    
    type proof_tree =
      | Goal of goal
      | Lemat of theorem
      | AndI  of node * proof_tree * proof_tree
      | AndE1 of node * proof_tree
      | AndE2 of node * proof_tree
      | ImpE  of node * proof_tree * proof_tree
      | ImpI  of node * proof_tree
      | BotE  of node * proof_tree
      | AllI  of node * proof_tree
      | AllE  of node * proof_tree * all_elim_info 
      | ExI   of node * proof_tree * ex_intro_info 
      | ExE   of node * proof_tree * proof_tree
      | OrI1  of node * proof_tree
      | OrI2  of node * proof_tree
      | OrE   of node * proof_tree * proof_tree * proof_tree
      | Equiv of node * proof_tree * equiv_info 
      | Ren   of node * proof_tree * ren_info
    
    type view = 
        | VGoal of goal
        | VLemat of theorem
        | VAndI  of node * proof_tree * proof_tree
        | VAndE1 of node * proof_tree
        | VAndE2 of node * proof_tree
        | VImpE  of node * proof_tree * proof_tree
        | VImpI  of node * proof_tree
        | VBotE  of node * proof_tree
        | VAllI  of node * proof_tree
        | VAllE  of node * proof_tree * all_elim_info 
        | VExI   of node * proof_tree * ex_intro_info 
        | VExE   of node * proof_tree * proof_tree
        | VOrI1  of node * proof_tree
        | VOrI2  of node * proof_tree
        | VOrE   of node * proof_tree * proof_tree * proof_tree
        | VEquiv of node * proof_tree * equiv_info 
        | VRen   of node * proof_tree * ren_info


    let view = function 
      | Goal (g) -> VGoal (g)
      | Lemat (th) -> VLemat (th)
      | AndI (n, pf1, pf2) -> VAndI (n, pf1, pf2)
      | AndE1 (n, pf) -> VAndE1 (n, pf)  
      | AndE2 (n, pf) -> VAndE2 (n, pf)
      | ImpE (n, pf1, pf2) -> VImpE (n, pf1, pf2)
      | ImpI (n,pf) -> VImpI (n,pf)
      | BotE (n, pf) -> VBotE (n, pf)
      | AllI (n, pf) -> VAllI (n, pf) 
      | AllE (n,pf,info) -> VAllE (n,pf,info)
      | ExI (n, pf, info) -> VExI (n, pf, info)
      | ExE (n, pf1, pf2) -> VExE (n, pf1, pf2)
      | OrI1 (n, pf) -> VOrI1 (n, pf)
      | OrI2 (n,pf) -> VOrI2 (n,pf)
      | OrE  (n, pf1, pf2, pf3) -> VOrE  (n, pf1, pf2, pf3)
      | Equiv (n, pf, info) -> VEquiv (n, pf, info)
      | Ren (n, pf, info) -> VRen (n, pf, info)



    (* Smart constructors*)
    let goal g = Goal g
    
    let lemat th = Lemat th
    

    let form_node (f, _, _) = f

    let ren_b node (v1, v2) = function 
      | Lemat th -> Lemat(ren th v1 v2)
      | pf       -> Ren (node, pf, (v1, v2))

    let equiv_b node f = function 
      | Lemat th -> Lemat (equiv th f)
      | pf       -> Equiv (node, pf, f)

    (* Implication smart constructors *)
    
    let impE node pf1 pf2 = match pf1, pf2 with
      | Lemat th1, Lemat th2 -> Lemat(imp_e th1 th2) 
      | pf1, pf2             -> ImpE (node, pf1, pf2)

    let impI node = function 
      | Lemat th -> Lemat (imp_i (form_node node) th)
      | pf       -> ImpI(node, pf) 
    
    let botE node = function 
      | Lemat th -> Lemat (bot_e th  (form_node node))
      | pf       -> BotE (node, pf)
    
    let allI node = function 
      | Lemat th -> Lemat (all_i th)
      | pf       -> AllI (node, pf)

    let allE term node = function 
      | Lemat th -> Lemat (all_e th term)
      | pf       -> AllE (node, pf, term)

    let exI (v, t, f) node = function 
      | Lemat th -> Lemat (ex_i th v t f)
      | pf       -> ExI (node, pf, (v, t, f))

    let exE node pf1 pf2 = match pf1, pf2 with
    | Lemat th1, Lemat th2 -> Lemat (ex_e th1 th2)
    | pf1, pf2             -> ExE (node, pf1 ,pf2)

    let andI node pf1 pf2 = match pf1, pf2 with
    | Lemat th1, Lemat th2 -> Lemat (and_i th1 th2)
    | pf1, pf2             -> AndI (node, pf1, pf2)
    
    let andE1 node = function
    | Lemat th -> Lemat (and_e1 th)
    | pf       -> AndE1 (node, pf)

    let andE2 node = function
    | Lemat th -> Lemat (and_e2 th)
    | pf       -> AndE2 (node, pf)

    let orI1 node = function
    | Lemat th -> begin match node with 
      | (Or (a,b ), _, _) -> Lemat (or_i1 th b)
      | _                 -> failwith "error" 
      end
    | pf       -> OrI1 (node, pf)

    let orI2 node = function
    | Lemat th -> begin match node with 
      | (Or (a,b ), _, _) -> Lemat (or_i2 th a)
      | _                 -> failwith "error" 
      end
    | pf       -> OrI1 (node, pf)

    let orE node pf1 pf2 pf3 = 
      match pf1, pf2, pf3 with
      | Lemat th1, Lemat th2, Lemat th3 -> Lemat (or_e th1 th2 th3)
      | pf1, pf2, pf3                   -> OrE (node, pf1, pf2, pf3)

  end
  open ProofTree
  type context = 
    | CRoot 
    | CAndIL  of context * node * proof_tree
    | CAndIR  of context * proof_tree
    | CAndE1  of context * node
    | CAndE2  of context * node
    | CImpeEL of context * node * proof_tree  
    | CImpeER of context * proof_tree  
    | CimpI   of context * node
    | CBotE   of context * node 
    | CAllI   of context * node
    | CAllE   of context * node * all_elim_info
    | CExI    of context * node * ex_intro_info 
    | CExEL   of context * node * proof_tree
    | CExER   of context * node * proof_tree
    | COrI1   of context * node
    | COrI2   of context * node
    | COrEL   of context * node * proof_tree * proof_tree
    | COmEL   of context * node * proof_tree * proof_tree
    | COlEL   of context * node * proof_tree * proof_tree
    | CEquiv  of context * node * equiv_info 
    | CRen    of context * node * ren_info

  type proof =
    | Complete of theorem
    | Sketch of goal * context

  let qed = function
  | Complete th -> th
  | Sketch _    -> failwith "proof is incomplete"

  let proof form assum bind =
    Sketch ((form, assum, bind), CRoot)

  let up_proof_tree pf ctx = 
      begin match ctx with
      | CRoot -> failwith "you are on top of proof tree"
      | CAndIL (ctx, n, r) -> andI n pf r, ctx
      | CAndIL (ctx, n, l) -> andI n l pf, ctx
      | CAndE1 (ctx, n)    -> andE1 n pf, ctx 
      | CAndEE (ctx, n)    -> andEe n pf, ctx 
      i

      end


end
