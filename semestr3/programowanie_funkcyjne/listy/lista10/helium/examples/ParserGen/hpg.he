
effect AtExit =
  { at_exit : (Unit ->[IO] Unit) => Unit }

let usageDoc =
  "Usage: hpg [OPTION]... FILE\nAvailable OPTIONs are:"

let argSpec =
  [ Arg.helpSwitch
  , Arg.helpKey
  , Arg.Default [Arg.Unique,Arg.Mandatory]
      (Arg.String "FILE" Settings.set_source)
  ]

let parseFile fname =
  let chan = openIn fname in
  at_exit (fn () => closeIn chan);
  handle Parsing.run Lexer.getToken Parser.file
  with CharStream.withChannel chan

let procFName fname =
  let grammar   = parseFile fname
  let automaton = LR0AutomatonGen.gen grammar
  in
  CodeGen.printCode automaton

let mainHandler settings f =
  handle
    handle
      handle f (); 0 with
      | Parsing.parse_error () =>
        outputString stderr ("Error: syntax error\n");
        2
      end
    with
    | Errors.symbol_not_defined sym =>
      outputString stderr ("Error: symbol `" ++ sym ++ "' is not defined.\n");
      1
    | Errors.symbol_redefinition sym =>
      outputString stderr
        ("Error: symbol `" ++ sym ++ "' is defined more than once\n");
      1
    | Errors.eof_in_code () =>
      outputString stderr ("Error: End of file inside code token.");
      2
    | Errors.eof_in_comment () =>
      outputString stderr ("Error: End of file inside block comment.");
      2
    | Errors.invalid_char c =>
      outputString stderr ("Error: Lexer error: invalid character");
      2
    | Errors.assertion_failed msg =>
      outputString stderr ("Assertion failed: " ++ msg ++ "\n");
      10
    end
  with
  | return exitCode => fn atExit =>
    List.iter (fn f => f ()) atExit;
    Sys.exit exitCode
  | at_exit cb => fn atExit => resume () (cb :: atExit)
  end []

let _ =
  let settings =
    handle Arg.parse argSpec usageDoc with Settings.setterHandler
  in
  handle procFName settings.Settings.source with mainHandler settings
