(** Generating LR0Automaton from Grammar *)

module G = Grammar
open LR0Automaton

module ProductKey = struct
  type this = Pair NTerm Int
  let compare = Ord.pair String.compare Int.compare
end
module ProductMap = Map(ProductKey)

(** Intermediate representation of automaton state *)
data MState =
| StateId  of StateId (** State declared, but not defined *)
| StateDef of State   (** State defined *)

module StateKey = struct
  type this = List ItemBlock
  let compare =
    let compareItemProduct ip1 ip2 =
      Ord.pair Int.compare (Ord.list Arg.compare)
        (ip1.ipProduct, ip1.ipArgs)
        (ip2.ipProduct, ip2.ipArgs)
    let compareItemBlock ib1 ib2 =
      Ord.pair
        (Ord.pair String.compare Int.compare)
        (Ord.list compareItemProduct)
        (ib1.ibNTerm, ib1.ibPos, ib1.ibProducts)
        (ib2.ibNTerm, ib2.ibPos, ib2.ibProducts)
    in
    Ord.list compareItemBlock
end
module StateMap = Map(StateKey)

module NTermSet = Set(String)
module ArgSet   = Set(Arg)

(* ========================================================================= *)
(** Translates productions of grammar g into two finite maps:
  1. from ProductId to Product
  2. from (Pair NTerm Int) to Product
    (from name of non-terminal and index) *)
let trProductions (g : Grammar) =
  effect RegisterProd =
    { register_production : G.NTerm, Int, G.Product => Unit }
  in
  handle
    G.SymMap.iter (fn nTerm sym =>
        List.iteri (register_production nTerm) sym.G.sProducts
      ) g.G.symbols
  with
  | return () => fn products productMap => (products, productMap)
  | register_production nTerm pIndex prod =>
    fn products productMap =>
      let prod =
        { pId    = IntMap.size products
        ; pNTerm = nTerm
        ; pIndex = pIndex
        ; pArgs  = prod.G.pArgs
        ; pCode  = prod.G.pCode
        }
      let products   = IntMap.add prod.pId prod products
      let productMap = ProductMap.add (nTerm, pIndex) prod productMap
      in
      resume () products productMap
  end IntMap.empty ProductMap.empty

(* ========================================================================= *)

(** Interraction with the environment of translation of states *)
effect TrState =
  (** ID of production for given non-terminal and production index *)
  { get_product_id : NTerm, Int => ProductId

  (** Definitions for given non-terminal *)
  ; get_symbol     : NTerm => G.Symbol

  (** Lookup for a state for given kernel *)
  ; lookup_state   : List ItemBlock => Option MState

  (** Delcare state for given kernel *)
  ; declare_state  : List ItemBlock => StateId

  (** Define state *)
  ; define_state   : State => Unit
  }

(** Translation of arguments *)
let trArg (arg : G.Arg) : Arg =
  match arg with
  | G.AnonToken  tok => AnonToken tok
  | G.ArgToken _ tok => ArgToken  tok
  | G.NTerm _ nTerm  => NTerm nTerm
  end

(** Generating inital block of items for given non-terminal *)
let nTermItemBlock (nTerm : NTerm) : ItemBlock =
  let trItemProduct (pIndex : Int) (prod : G.Product) : ItemProduct =
    { ipArgs    = List.map trArg prod.G.pArgs
    ; ipProduct = get_product_id nTerm pIndex
    }
  let products = List.mapi trItemProduct (get_symbol nTerm).G.sProducts
  in
  { ibNTerm    = nTerm
  ; ibPos      = 0
  ; ibProducts = products
  }

(** Computes closure of a kernel, i.e. list of non-terminals that
  can be accepted in a state represented by a kernel *)
let kernelClosure (kernel : List ItemBlock) =
  effect rec WorkSet R =
    { add_to_closure : NTerm => Unit ->[WorkSet R|R] Unit }
  let processItemBlock ib =
    List.iter (fn prod =>
        match prod.ipArgs with
        | NTerm nTerm :: _ => add_to_closure nTerm ()
        | _ => ()
        end
      ) ib.ibProducts
  in
  handle List.iter processItemBlock kernel with
  | return () => NTermSet.toList
  | add_to_closure nTerm => fn closure =>
    if NTermSet.mem nTerm closure then
      resume (fn () => ()) closure
    else
      resume
        (fn () => processItemBlock (nTermItemBlock nTerm))
        (NTermSet.add nTerm closure)
  end NTermSet.empty

(** Collects reduce rules *)
let collectReduceRules (blocks : List ItemBlock) =
  handle 
    List.iteri (fn contId ib =>
        List.iter (fn prod =>
            match prod.ipArgs with
            | [] => Writer.tell
              { rrProduct = prod.ipProduct
              ; rrCont    = contId
              ; rrArgN    = ib.ibPos
              }
            | _ :: _ => ()
            end
          ) ib.ibProducts
      ) blocks
  with Writer.listHandler

(** Collects possible moves *)
let collectMoves (blocks : List ItemBlock) =
  ArgSet.toList
    (handle
      List.iter (fn ib =>
          List.iter (fn prod =>
              match prod.ipArgs with
              | []       => ()
              | arg :: _ => Writer.tell arg
              end
            ) ib.ibProducts
        ) blocks
    with Writer.accHandler ArgSet.empty ArgSet.add)

(** Produce new list of blocks after arg transition.
  Returns list of pairs containing block and continuation index *)
let shiftBlocks (blocks : List ItemBlock) (arg : Arg) =
  let shiftItemProducts prods =
    handle
      List.iter (fn prod =>
          match prod.ipArgs with
          | [] => ()
          | arg' :: args =>
            if Arg.equal arg arg' then
              Writer.tell
              { ipArgs    = args
              ; ipProduct = prod.ipProduct
              }
          end
        ) prods
    with Writer.listHandler
  in
  handle
    List.iteri (fn contId ib =>
        match shiftItemProducts ib.ibProducts with
        | [] => ()
        | prods => Writer.tell (
          { ibNTerm    = ib.ibNTerm
          ; ibPos      = ib.ibPos + 1
          ; ibProducts = prods
          }, contId)
        end
      ) blocks
  with Writer.listHandler

(** Computes numer of arguments expected by given kernel
  as a maximum position of item-block *)
let kernelArgN (kernel : List ItemBlock) =
  handle List.iter (fn ib => Writer.tell ib.ibPos) kernel
  with Writer.accHandler 0 Int.max

(** Returns stateID for given kernel and args.
  if state is not declared, then function declares it, and
  generates the state and all states accessible from it *)
let rec getStateId (kernel : List ItemBlock) (args : List Arg) : Int =
  match lookup_state kernel with
  | Some (StateId  id) => id
  | Some (StateDef st) => st.sId
  | None =>
    let id = declare_state kernel
    let st = trState id kernel args
    let _  = define_state st
    in id
  end

(** Produce state representation *)
and trState id kernel args : State / [TrState] =
  let closure     = kernelClosure kernel
  let blocks      = kernel @ List.map nTermItemBlock closure
  let reduceRules = collectReduceRules blocks
  let moves       = collectMoves blocks
  let links       =
    handle
      List.iter (fn arg =>
          Writer.tell (arg, trLink blocks args arg)
        ) moves
    with Writer.accHandler
      ArgMap.empty
      (fn (arg, link) => ArgMap.add arg link)
  in
  { sId          = id
  ; sArgs        = args
  ; sKernel      = kernel
  ; sClosure     = closure
  ; sReduceRules = reduceRules
  ; sLinks       = links
  }

(** Produce transition representation *)
and trLink blocks args arg : Link / [TrState] =
  let cBlocks = shiftBlocks blocks arg
  let kernel  = List.map fst cBlocks
  let conts   = List.map snd cBlocks
  let argN    = kernelArgN kernel
  in
  { lConts = conts
  ; lState = getStateId kernel (List.take argN (arg :: args))
  ; lArgN  = argN
  }

(** Translation of initial states *)
(** Returns states and initStates of the automaton *)
let trStates (g : Grammar) (productMap : ProductMap Product) =
  handle
    handle
      G.SymMap.iter (fn nTerm sym =>
          if sym.G.sInit then begin
            let args   = []
            let kernel = [ nTermItemBlock nTerm ]
            in
            Writer.tell
              { isNTerm = nTerm
              ; isState = getStateId kernel args
              }
          end
        ) g.G.symbols
    with Writer.listHandler
  with
  | return initStates => fn states stateMap => (initStates, states)
  | get_product_id nTerm pIndex =>
    handle ProductMap.find (nTerm, pIndex) productMap with
    | return prod     => resume prod.pId
    | Map.not_found _ => Errors.assertion_failed "Production does not exist"
    end
  | get_symbol nTerm =>
    handle G.SymMap.find nTerm g.G.symbols with
    | return sym      => resume sym
    | Map.not_found _ => Errors.symbol_not_defined nTerm
    end
  | lookup_state kernel / res => fn states stateMap =>
    handle StateMap.find kernel stateMap with
    | return st       => res (Some st) states stateMap
    | Map.not_found _ => res None states stateMap
    end
  | declare_state kernel => fn states stateMap =>
    let id = StateMap.size stateMap in
    resume id states (StateMap.add kernel (StateId id) stateMap)
  | define_state st => fn states stateMap =>
    resume ()
      (IntMap.add st.sId st states)
      (StateMap.add st.sKernel (StateDef st) stateMap)
  end IntMap.empty StateMap.empty

(* ========================================================================= *)
(** Translation of grammar to automaton *)
let gen (g : Grammar) : LR0Automaton =
  let (products, productMap) = trProductions g
  let (initStates, states)   = trStates g productMap
  in
  { preambleCode = g.G.preambleCode
  ; products     = products
  ; states       = states
  ; initStates   = initStates
  }
