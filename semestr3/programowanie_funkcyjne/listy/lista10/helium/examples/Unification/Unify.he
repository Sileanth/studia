effect Assoc K R V = { assoc : K, (Unit ->[R] V) => V }

data rec Term Sig Var = Var of Var | Term of Sig (Term Sig Var)

data UnifError T = UECirc | UEMismatch of T, T

module Unify =
functor
  (S : sig
    type this : type -> type
    val fmap : type A B R. (A ->[R] B) -> this A ->[R] this B
    val zipWith : type A B C R. (A -> B ->[R] C) -> this A -> this B -> [Error (Pair (this A) (this B)), R] this C
  end)
  (V : sig
    type this
    val  assocH : type E1 E2 V X. (Unit -> [Assoc this E1 V, E1, E2] X) ->[E1, E2] Pair X (List (Pair this V))
    val  print : this -> String
  end) :
sig
  type UTerm
  effect Unify
  effect UnifySeal

  val convert : Term S V ->[Unify] UTerm
  val unify   : UTerm -> UTerm ->[Unify] Unit
  val project : UTerm ->[UnifySeal, Error (UnifError (S UTerm))] Term S V
  val sealH   : type E X. (Unit ->[Unify, E] X) ->[UnifySeal, Error (UnifError (S UTerm)), RE, E] X
  val unifyH  : type E X. (Unit ->[UnifySeal, Error (UnifError (S UTerm)), E] X) ->[Error (UnifError (S UTerm)), E] X

end =>
struct
  open UnionFind
  data Rep T = USig of S T | UVar of V | URec | UDone of Term S V
  data rec UTerm = UTerm of Set (Rep UTerm)
  effect Unify = ([Assoc V [UF (Rep UTerm)] UTerm, UF (Rep UTerm), Writer (Pair UTerm UTerm)])
  effect UnifySeal = ([Assoc V [UF (Rep UTerm)] UTerm, UF (Rep UTerm)])

  let rec convert t =
    match t with
    | Var x  => assoc x (fn () => UTerm (new (UVar x)))
    | Term f => UTerm (new (USig (S.fmap convert f)))
    end

  let addAndPick a b = Writer.tell (a, b); a
  let uniteSyms s1 s2 =
    match s1, s2 with
    | URec, _    => runtimeError "Phase distinction violated"
    | _, URec    => runtimeError "Phase distinction violated"
    | UDone _, _ => runtimeError "Phase distinction violated"
    | _, UDone _ => runtimeError "Phase distinction violated"
    | _, UVar _  => s1
    | UVar _, _  => s2
    | USig f1, USig f2 =>
      handle USig (S.zipWith addAndPick f1 f2) with
      | error (t1, t2) => error (UEMismatch t1 t2)
      end
    end

  let process p =
    let (UTerm s1, UTerm s2) = p in
    union uniteSyms s1 s2

  let unify t1 t2 =
    Writer.tell (t1, t2)

  let switchRep s t = union (fn _ r => r) s (new t)

  let rec project (UTerm s) =
    match find s with
    | URec    => error UECirc
    | UDone t => t
    | UVar x  => let t = Var x in switchRep s (UDone t); t
    | USig f  =>
      switchRep s URec;
      let t = Term (S.fmap project f)
      in switchRep s (UDone t); t
    end

  let sealH p =
    handle p ()
    with Writer.workSetHandler process

  let unifyH p =
    handle
      let (r, kvs) =
        handle p ()
        with V.assocH
      in List.iter (fn (_, s) => (let _ = project s in ())) kvs; r
    with
      withUF $>
      assertNoError "Correct UF Set usage enforced as an invariant."

end
