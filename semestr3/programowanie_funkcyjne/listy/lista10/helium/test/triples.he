(** fail and amb as presented in "Abstracting Control" *)

effect NonDet =
  { fail : type A. Unit => A
  ; amb  : Unit => Bool }

let withNonDet c =
  handle c () with
    | return () => ()
    | fail () => ()
    | amb () => resume True; resume False
  end

(**********)

let c0 () = printInt 1
let _ = printStr "c0:\n"; withNonDet c0; printStr "***\n"

let c1 () = if amb () then 1 else 2
let _ = printStr "c1:\n"; withNonDet (fn () => printInt (c1 ())); printStr "***\n"

let c2 () =
  if amb ()
  then if amb () then 1 else 2
  else if amb () then 3 else 4
let _ = printStr "c2:\n"; withNonDet (fn () => printInt (c2 ())); printStr "***\n"

let c3 () =
  if amb ()
  then if amb () then 1 else fail ()
  else if amb () then 3 else 4
let _ = printStr "c3:\n"; withNonDet (fn () => printInt (c3 ())); printStr "***\n"

let c4 () =
  fail ()
let _ = printStr "c4:\n"; withNonDet (fn () => printInt (c4 ())); printStr "***\n"

(**********)

data Triple = T of Int, Int, Int

let stringOfTriple t =
  match t with
  | T i j k => "(" ++ stringOfInt i ++ ", " ++ stringOfInt j ++ ", " ++ stringOfInt k ++ ")"
  end

let printTriple t =
    printStr (stringOfTriple t ++ "\n")

let rec choice n =
  if n > 0
  then if amb ()
       then choice (n - 1)
       else n
  else fail ()

let triple n s =
  let i = choice n
  in let j = choice (i - 1)
     in let k = choice (j - 1)
	in if i + j + k = s
	   then T i j k
	   else fail ()

let triples_9_15 = withNonDet (fn () => printTriple (triple 9 15))

(**********)

let stringOfIntList xs =
  let rec loop xs =
    match xs with
    | [] => ""
    | x :: xs => ", " ++ stringOfInt x ++ loop xs
    end
  in match xs with
     | [] => "[]"
     | x :: xs => "[" ++ stringOfInt x ++ loop xs ++ "]"
     end

effect Collect A =
  { emit : A => Unit }

let withCollect c =
  handle c () with
  | return () => []
  | emit v => v :: resume ()
  end

let _ = printStr (stringOfIntList (withCollect (fn () => withNonDet (fn () => emit (c2 ())))) ++ "\n")
let _ = printStr (stringOfIntList (withCollect (fn () => withNonDet (fn () => emit (c3 ())))) ++ "\n")
let _ = printStr (stringOfIntList (withCollect (fn () => withNonDet (fn () => emit (c4 ())))) ++ "\n")

(**********)

let withPrintResults c =
  handle c () with
  | return () => ()
  | emit v => printInt v; resume ()
  end

let withCollectResults = withCollect

let () = withPrintResults (fn () => withNonDet (fn () => emit (c3 ())))

let vs = withCollectResults (fn () => withNonDet (fn () => emit (c3 ())))
let _ =  printStr (stringOfIntList vs ++ "\n")

(**********)

let withNonDetCollect h c =
  h (fn () => withNonDet (fn () => emit (c ())))

let withPrint = withNonDetCollect withPrintResults
let withList = withNonDetCollect withCollectResults

let () = withPrint c3

let vs = withList c3
let _ =  printStr (stringOfIntList vs ++ "\n")

(* EoF *)
