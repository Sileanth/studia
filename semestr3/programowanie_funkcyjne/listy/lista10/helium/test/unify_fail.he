effect State T =
  { put : T    => Unit
  ; get : Unit => T
  }

let withState = fn f =>
  handle f () with
  | return x   => fn _ => x
  | put t  / r => fn _ => r () t
  | get () / r => fn t => r t  t
  end

data rec Nat = Z | S of Nat

let rec natEqual x y =
  match x, y with
  | Z,   Z   => True
  | S x, S y => natEqual x y
  | _        => False
  end

effect WorkSet T = { add_to_set : T => Unit }

let processSet f c =
  let rec handleWS th =
    handle th () with
    | return () => fn xs => procList xs
    | add_to_set x / r => fn xs => r () (x :: xs)
    end
  and procList xs =
    match xs with
    | []      => ()
    | x :: xs => handleWS (fn () => f x) xs
    end
  in
  handleWS c []

let rec nth xs n default =
  match xs with
  | []      => default
  | x :: xs =>
    match n with
    | Z   => x
    | S n => nth xs n default
    end
  end

let rec assoc xs n =
  match xs with
  | []           => None
  | (k, v) :: xs =>
    match natEqual n k with
    | True  => Some v
    | False => assoc xs n
    end
  end

let rec updateList xs n v =
  match xs with
  | []      => []
  | x :: xs =>
    match n with
    | Z   => v :: xs
    | S n => x :: updateList xs n v
    end
  end

data UFOps Set UF =
  { new    : type Elem. Elem ->[UF Elem] Set Elem
  ; find   : type Elem. Set Elem ->[UF Elem] Elem
  ; union  : type Elem R. (Elem -> Elem ->[| R] Elem) ->
                          Set Elem -> Set Elem ->[UF Elem | R] Unit
  ; withUF : type Elem RR RT. (Unit ->[UF Elem | RR] RT) ->[| RR] RT
  }
data UnionFind = UnionFind of type Set UF. UFOps Set UF

let UnionFind (type Set UF)
    { new = new; find = find; union = union; withUF = withUF } =
  data Set T = T of Nat in
  let insEnd e =
    let rec aux acc xs cont =
      match xs with
      | []      => cont acc (e :: [])
      | x :: xs => aux (S acc) xs (fn n ys => cont n (x :: ys))
      end
    in aux Z in
  effect UFS T =
    { new    : T    => Nat
    ; lookup : Nat  => Either Nat T
    ; update : Nat, (Either Nat T) => Unit
    } in
  let rec find x =
    let (T x) = x in
    match lookup x with
    | Left y =>
        let t = find (T y) in
        update x (Right t);
        t
    | Right t => t
    end in
  let union f x y =
    let t1 = find x in
    let t2 = find y in
    let (T x) = x in
    let (T y) = y in
    update x (Right (f t1 t2));
    update y (Left x) in
  let doIt f =
    handle f () with
    | return b   => fn _ => b
    | new e      => fn l => insEnd (Right e) l resume
    | lookup x   => fn l => resume (nth l x (Left Z)) l
    | update x v => fn l => resume () (updateList l x v)
    end [] in
  UnionFind { new = (fn x => T (new x)); find = find; union = union; withUF = doIt }

let printBool b =
  match b with
  | True  => printInt 42
  | False => printInt 0
  end

effect Error = {error : type T. Unit => T}

data rec GTerm Sig = GTerm of Sig (GTerm Sig)

data rec OTerm Sig V = Var of V | OTerm of Sig (OTerm Sig V)

effect FMap Sig =
  { fmap  : type A B R. (A ->[|R] B) => Sig A ->[|R] Sig B
  ; zipWith : type A B C R. (A -> B ->[|R] C) => Sig A -> Sig B ->[Error|R] Sig C
  }

let unify (type Sig) t1 t2 =
  data rec UTerm = UTerm of Set (Option (Sig UTerm)) in
  let rec walkTree t =
    UTerm
    match t with
    | Var x =>
      let xs = get () in
      match assoc xs x with
      | Some (UTerm s) => s
      | None =>
        let s = new None in
        put ((x, UTerm s) :: xs);
        s
      end
    | OTerm f =>
      new (Some (fmap walkTree f))
    end in
  let uniteSyms s1 s2 =
    match s1, s2 with
    | None, _ => s2
    | _, None => s1
    | Some f1, Some f2 =>
      Some (zipWith (fn a b =>
          add_to_set (a, b);
          a
        ) f1 f2)
    end in
  let process p =
    let (UTerm s1, UTerm s2) = p in
    union uniteSyms s1 s2 in
  handle
    withUF (fn () =>
      let ps = withState (fn () => (walkTree t1, walkTree t2)) [] in
      processSet process (fn () => add_to_set ps))
  with
  | return () => True
  | error  () => False
  end

data Sig T = SBool | SProd of T, T | SArrow of T, T

let sig_fmap f x =
  match x with
  | SBool      => SBool
  | SProd  x y => SProd  (f x) (f y)
  | SArrow x y => SArrow (f x) (f y)
  end

let sig_zipWith f x1 x2 =
  match x1, x2 with
  | SBool, SBool => SBool
  | SBool, _     => error ()
  | SProd a1 b1, SProd a2 b2 =>
    SProd (f a1 a2) (f b1 b2)
  | SProd _ _, _ => error ()
  | SArrow a1 b1, SArrow a2 b2 =>
    SArrow (f a1 a2) (f b1 b2)
  | SArrow _ _, _ => error ()
  end

let printify t1 t2 =
  handle printBool (unify t1 t2) with
  | fmap  f => resume (sig_fmap  f)
  | zipWith f => resume (sig_zipWith f)
  end

let _ = printify (OTerm SBool) (OTerm SBool)
let _ = printify (OTerm SBool) (Var Z)
let _ = printify (OTerm SBool) (OTerm (SProd (OTerm SBool) (Var Z)))
let _ = printify (OTerm (SArrow (Var Z) (Var (S Z)))) (OTerm (SArrow (Var (S Z)) (OTerm SBool)))
let _ = printify (OTerm (SArrow (Var Z) (Var (S Z)))) (Var Z)
