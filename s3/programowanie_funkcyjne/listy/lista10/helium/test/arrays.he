data Bool = True | False
data Pair X Y = Pair of X, Y
data Option X = Some of X | None
data Either L R = Left of L | Right of R

data rec Pos = Z of Pos | O of Pos | One
data Nat = P of Pos | Zero

let rec posEqual x y =
  match Pair x y with
  | Pair One One => True
  | Pair (Z x) (Z y) => posEqual x y
  | Pair (O x) (O y) => posEqual x y
  | _ => False
  end
   
let natEqual n1 n2 =
  match Pair n1 n2 with
  | Pair Zero Zero => True
  | Pair (P x) (P y) => posEqual x y
  | _ => False
  end

let rec succPos x =
  match x with
  | One => Z One
  | Z x => O x
  | O x => Z (succPos x)
  end

let succ x =
  match x with
  | Zero => One
  | P x  => succPos x
  end

let rec addPos x y =
  match Pair x y with
  | Pair One _ => succPos y
  | Pair _ One => succPos x
  | Pair (Z x) (Z y) => Z (addPos x y)
  | Pair (Z x) (O y) => O (addPos x y)
  | Pair (O x) (Z y) => O (addPos x y)
  | Pair (O x) (O y) => Z (succPos (addPos x y))
  end

let add x y =
  match Pair x y with
  | Pair Zero _ => y
  | Pair _ Zero => x
  | Pair (P x) (P y) => P (addPos x y)
  end

let div2 x =
  match x with
  | Zero => Zero
  | P One => Zero
  | P (Z x) => P x
  | P (O x) => P x
  end

let even x =
  match x with
  | Zero => True
  | P One => False
  | P (Z _) => True
  | P (O _) => False
  end

effect Error = { error : type T. Unit => T }

data rec BT X = Leaf | Node of BT X, X, BT X
data Array X  = Arr of Nat, (BT X)

let rec lookup t n =
  match t with
  | Leaf => error ()
  | Node l x r =>
    match n with
    | One => x
    | Z n => lookup l n
    | O n => lookup r n
    end
  end

let rec update t n v =
  match t with
  | Leaf => error ()
  | Node l x r =>
    match n with
    | One => Node l v r
    | Z n => Node (update l n v) x r
    | O n => Node l x (update r n v)
    end
  end

let rec extend t n v =
  match Pair t n with
  | Pair Leaf One => Node Leaf v Leaf
  | Pair Leaf _   => error ()
  | Pair _ One    => error ()
  | Pair (Node l x r) (Z n) => Node (extend l n v) x r
  | Pair (Node l x r) (O n) => Node l x (extend r n v)
  end

let rec arrGet (Arr n t) k =
  lookup t k (* comparison is as costly as lookup *)

let rec arrUpd (Arr n t) k v =
  Arr n (update t k v)

let rec arrSize (Arr n _) = n

let rec arrExt (Arr n t) v =
  let m = succ n in
  Arr (P m) (extend t m v)

let arrNew () = Arr Zero Leaf

(** The effect used by the Union-Find implementation implemented
    via balanced binary tree-based persistent array. Some invariants
    cannot be enforced, obviously. *)

let rec loop () = loop ()

effect UFS T =
  { new    : T    => Pos
  ; lookup : Pos  => Either Pos T
  ; update : Pos, (Either Pos T) => Unit
  }

(* type annotation necessary to avoid accidental killing off of f's errors *)
let handleUFS (type E T R) (f : Unit ->[UFS E | R] T) =
  handle
    handle f () with
    | return x => fn _ => x
    | new t    => fn s =>
      let n = succ (arrSize s) in
      let s = arrExt s (Right t) in
      resume n s
    | lookup n => fn s =>
        resume (arrGet s n) s
    | update n v => fn s =>
        resume () (arrUpd s n v)
    end (arrNew ())
  with
  | return x => x
  | error () => loop () (* Invariant: impossible *)
  end
