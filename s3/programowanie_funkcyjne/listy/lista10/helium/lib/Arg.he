(** Parsing command line arguments *)

type KeyArgName = String
type Switch     = Char
type Key        = String
type Doc        = String
type UsageDoc   = String

(** Argument of a keyword *)
data rec KeyArg R =
(** Do not expect any argument and call given function. *)
| Unit     of (Unit ->[|R] Unit)
(** Call the function on argument. *)
| String   of KeyArgName, (String ->[|R] Unit)
(** Call the function on Int argument. *)
| Int      of KeyArgName, (Int    ->[|R] Unit)
(** Expect one of given symbol names and call the function on value associated
  with the read symbol *)
| Symbol   of type Sym. KeyArgName, List (Pair String Sym), (Sym ->[|R] Unit)
(** Take several arguments *)
| Tuple    of List (KeyArg R)
(** Stop interpreting arguments and call given function on each of the rest
  arguments *)
| RestIter of (String ->[|R] Unit)
(** Stop interpreting arguments and cakk given function on rest of arguments *)
| RestAll  of (List String ->[|R] Unit)

(** Additional requirements on command-line arguments *)
data Flag =
(** This type of argument may be used only ones *)
| Unique
(** This type of argument is mandatory *)
| Mandatory
(** This type of argument was already used (this flag is set by the parsing
  engine) *)
| Hit

(** Specification of arguments *)
data ArgSpec R =
(** Switches starts with single dash (e.g., -l). Several switches can be
  passed at once in a single argument (e.g. -lxa). *)
| Switch  of Switch, List Flag, (Unit ->[|R] Unit), Doc
(** Keys starts with double dash (e.g. --do-somethig) and may expect arguments
  according to KeyArg. *)
| Key     of Key, List Flag, KeyArg R, Doc
(** Specification of anonymous arguments, i.e., all arguments that are single
  dash "-" or does not start with a dash.
  You can specify more than one default argument provided all except the last
  are declared Unique. When more than one anonymous argument is declared, then
  the engine calls the action of the first one which is not both unique and
  hit. Anonymous arguments cannot be of type Unit *)
| Default of List Flag, KeyArg R

(** Errors that may occur during parsing *)
data ErrorReason =
| ErrMissingArg             of KeyArgName, Option Key
| ErrInvalidInteger         of KeyArgName, Option Key, String
| ErrInvalidSymbol          of KeyArgName, Option Key, String, List String
| ErrUnknownSwitch          of Switch
| ErrUnknownKey             of Key
| ErrExtraArg               of String
| ErrUniqueSwitchRepetition of Switch
| ErrUniqueKeyRepetition    of Key
| ErrMissingMandatorySwitch of Switch
| ErrMissingMandatoryKey    of Key
| ErrMissingMandatoryArg

effect Error R =
  { parse_error : List (ArgSpec R), UsageDoc, ErrorReason => a }

(* Implementation. See below for specification. *)
include struct
  effect rec this R =
    { getSpec        : Unit => List (ArgSpec [this R|R])
    ; setSpec        : List (ArgSpec [this R|R]) => Unit
    ; getRest        : Unit => List String
    ; setRest        : List String => Unit
    ; getUsageDoc    : Unit => UsageDoc
    ; setUsageDoc    : UsageDoc => Unit
    ; checkMandatory : Unit => Unit
    ; current_key    : Unit => Option Key
    ; set_key        : Option Key => Unit
    }

  (* ============================================================= *)
  (* Other effects expressed using basic effects *)

  let expand args =
    setRest (args @ getRest ())

  let popArg () =
    match getRest () with
    | []          => None
    | arg :: rest =>
      setRest rest;
      Some arg
    end

  let error reason =
    parse_error (getSpec ()) (getUsageDoc ()) reason

  let getArg name =
    match popArg () with
    | None     => error (ErrMissingArg name (current_key ()))
    | Some arg => arg
    end

  (* ============================================================= *)
  (* Printing *)

  let printErrorReason reason =
    let ofOption opt =
      match opt with
      | None => ""
      | Some key => " of option " ++ key
      end
    in
    match reason with
    | ErrMissingArg name opt =>
      Writer.tell ("Missing argument " ++ name ++ ofOption opt)
    | ErrInvalidInteger name opt _ =>
      Writer.tell ("Argument " ++ name ++ ofOption opt ++
        " should be an integer")
    | ErrInvalidSymbol name opt _ _ =>
      Writer.tell ("Invalid argument " ++ name ++ ofOption opt)
    | ErrUnknownSwitch sw =>
      Writer.tell ("Unknown switch -" ++ String.repeat 1 sw)
    | ErrUnknownKey key =>
      Writer.tell ("Unknown option " ++ key)
    | ErrExtraArg _ =>
      Writer.tell ("Too many arguments")
    | ErrUniqueSwitchRepetition sw =>
      Writer.tell ("Switch -" ++ String.repeat 1 sw ++
        " cannot be used more then once")
    | ErrUniqueKeyRepetition key =>
      Writer.tell ("Option " ++ key ++ " cannot be used more then once")
    | ErrMissingMandatorySwitch sw =>
      Writer.tell ("One of mandatory switches were not used")
    | ErrMissingMandatoryKey key =>
      Writer.tell ("Mandatory option " ++ key ++ " were not used")
    | ErrMissingMandatoryArg =>
      Writer.tell "Missing argument"
    end

  let rec prettyKeyArg keyArg =
    match keyArg with
    | Unit   _      => ""
    | String name _ => " " ++ name
    | Int    name _ => " " ++ name
    | Symbol _ [] _ => " {}"
    | Symbol _ ((s,_) :: syms) _ =>
      " {" ++ s ++ List.foldl (fn acc (s,_) => acc ++ "|" ++ s) "" syms ++ "}"
    | Tuple  keyArgs =>
      List.foldl (fn acc keyArg => acc ++ prettyKeyArg keyArg) "" keyArgs
    | RestIter _ => ""
    | RestAll  _ => ""
    end

  let printArgSpec argSpec =
    let align = 24 in
    match argSpec with
    | Switch c _ _ doc =>
      Writer.tell ("  -" ++ String.repeat 1 c);
      Writer.tell (String.repeat (align - 4) ' ' ++ doc);
      Writer.tell "\n"
    | Key key _ arg doc =>
      let keyDoc = "  " ++ key ++ prettyKeyArg arg
      let len    = String.length keyDoc in
      Writer.tell keyDoc;
      if len < align then
        Writer.tell (String.repeat (align - len) ' ')
      else
        Writer.tell ("\n" ++ String.repeat align ' ');
      Writer.tell (doc ++ "\n")
    | Default _ _ => ()
    end

  let printHelpP spec usageDoc =
    Writer.tell usageDoc;
    Writer.tell "\n";
    List.iter printArgSpec spec

  let printHelp () =
    printHelpP (getSpec ()) (getUsageDoc ())

  (* ============================================================= *)
  (* Interpreting KeyArgs *)

  let rec findSymbol arg syms =
    match syms with
    | [] => None
    | (name, sym) :: syms =>
      if String.equal arg name then Some sym
      else findSymbol arg syms
    end

  let liftError (type A R1 R2 B) (f : A ->[|R2] B) =
    f : A ->[Error R1|R2] B

  let rec parseArg keyArg =
    match keyArg with
    | Unit   f      => liftError f ()
    | String name f => liftError f (getArg name)
    | Int    name f =>
      let arg = getArg name in
      handle Int.ofString arg with
      | return n => liftError f n
      | Prelude.parse_error () =>
        error (ErrInvalidInteger name (current_key ()) arg)
      end
    | Symbol name syms f =>
      let arg = getArg name in
      match findSymbol arg syms with
      | Some sym => liftError f sym
      | None     =>
        error (ErrInvalidSymbol name (current_key ()) arg (List.map fst syms))
      end
    | Tuple keyArgs => List.iter parseArg keyArgs
    | RestIter f =>
      let rec loop () =
        match popArg () with
        | None     => ()
        | Some arg =>
          liftError f arg;
          loop ()
        end
      in loop ()
    | RestAll f =>
      let args = getRest ()
      let _    = setRest []
      in liftError f args
    end

  (* ============================================================= *)
  (* Operations on flags *)

  let isUnique flags =
    List.exists (fn flag =>
      match flag with
      | Unique => True
      | _      => False
      end) flags

  let isHit flags =
    List.exists (fn flag =>
      match flag with
      | Hit => True
      | _   => False
      end) flags

  let isMandatory flags =
    List.exists (fn flag =>
      match flag with
      | Mandatory => True
      | _         => False
      end) flags

  let hit flags =
    if isHit flags then flags
    else Hit :: flags

  (* ============================================================= *)
  (* Finding in spec *)

  let rec findSwitch sw spec =
    match spec with
    | [] => error (ErrUnknownSwitch sw)
    | argSpec :: spec =>
      match argSpec with
      | Switch sw' flags f doc =>
        if Char.equal sw sw' then begin
          if isUnique flags && isHit flags then
            error (ErrUniqueSwitchRepetition sw)
          else
            (Switch sw' (hit flags) f doc :: spec, f)
        end else begin
          let (spec, f) = findSwitch sw spec in
          (argSpec :: spec, f)
        end
      | _ =>
        let (spec, f) = findSwitch sw spec in
        (argSpec :: spec, f)
      end
    end

  let rec findKey key spec =
    match spec with
    | [] => error (ErrUnknownKey key)
    | argSpec :: spec =>
      match argSpec with
      | Key key' flags keyArg doc =>
        if String.equal key key' then begin
          if isUnique flags && isHit flags then
            error (ErrUniqueKeyRepetition key)
          else
            (Key key' (hit flags) keyArg doc :: spec, keyArg)
        end else begin
          let (spec, keyArg) = findKey key spec in
          (argSpec :: spec, keyArg)
        end
      | _ =>
        let (spec, keyArg) = findKey key spec in
        (argSpec :: spec, keyArg)
      end
    end

  let rec findDefault arg spec =
    match spec with
    | [] => error (ErrExtraArg arg)
    | argSpec :: spec =>
      match argSpec with
      | Default flags keyArg =>
        if isUnique flags && isHit flags then begin
          let (spec, keyArg) = findDefault arg spec in
          (argSpec :: spec, keyArg)
        end else
          (Default (hit flags) keyArg :: spec, keyArg)
      | _ =>
        let (spec, keyArg) = findDefault arg spec in
        (argSpec :: spec, keyArg)
      end
    end

  (* ============================================================= *)
  (* Arguments types *)

  let isSwitch arg =
    if String.length arg > 1 then
      Char.equal (String.get 0 arg) '-'
      && not (Char.equal (String.get 1 arg) '-')
    else False

  let isKey arg =
    if String.length arg > 1 then
      Char.equal (String.get 0 arg) '-'
      && Char.equal (String.get 1 arg) '-'
    else False

  (* ============================================================= *)
  (* Parsing loops *)

  let rec switchIter pos arg =
    if pos >= String.length arg then ()
    else begin
      let (spec, f) = findSwitch (String.get pos arg) (getSpec ()) in
      setSpec spec;
      liftError f ();
      switchIter (pos+1) arg
    end

  let rec parseLoop () =
    match popArg () with
    | None => checkMandatory ()
    | Some arg =>
      if isSwitch arg then
        switchIter 1 arg
      elif isKey arg then begin
        let (spec, keyArg) = findKey arg (getSpec ()) in
        setSpec spec;
        set_key (Some arg);
        parseArg keyArg
      end else begin
        expand [arg];
        let (spec, keyArg) = findDefault arg (getSpec ()) in
        setSpec spec;
        set_key None;
        parseArg keyArg
      end;
      parseLoop ()
    end

  (* ============================================================= *)
  (* Parsing engine *)

  data State R =
    { spec  : List (ArgSpec R)
    ; args  : List String
    ; key   : Option Key
    ; usage : UsageDoc
    }

  let runMandatoryCheck spec usage =
    List.iter (fn argSpec =>
      match argSpec with
      | Switch sw flags _ _ =>
        if isMandatory flags && not (isHit flags) then
          parse_error spec usage (ErrMissingMandatorySwitch sw)
      | Key key flags _ _ =>
        if isMandatory flags && not (isHit flags) then
          parse_error spec usage (ErrMissingMandatoryKey key)
      | Default flags _ =>
        if isMandatory flags && not (isHit flags) then
          parse_error spec usage ErrMissingMandatoryArg
      end) spec

  let parseArgs spec usageDoc args =
    handle parseLoop () with
    | return ()    => fn state => ()
    | getSpec ()   => fn state => resume state.spec state
    | setSpec spec => fn state =>
      resume ()
        { spec  = spec
        ; args  = state.args
        ; key   = state.key
        ; usage = state.usage
        }
    | getRest ()   => fn state => resume state.args state 
    | setRest args => fn state =>
      resume ()
        { spec  = state.spec
        ; args  = args
        ; key   = state.key
        ; usage = state.usage
        }
    | getUsageDoc ()    => fn state => resume state.usage state
    | setUsageDoc usage => fn state =>
      resume ()
        { spec  = state.spec
        ; args  = state.args
        ; key   = state.key
        ; usage = usage
        }
    | checkMandatory () => fn state =>
      runMandatoryCheck state.spec state.usage;
      resume () state
    | current_key () => fn state => resume state.key state
    | set_key key    => fn state =>
      resume ()
        { spec  = state.spec
        ; args  = state.args
        ; key   = key
        ; usage = state.usage
        }
    end
      { spec  = spec
      ; args  = args
      ; key   = None
      ; usage = usageDoc
      }

  let parse spec usageDoc =
    handle parseArgs spec usageDoc Sys.args with
    | return () => ()
    | parse_error spec usageDoc reason =>
      handle
        printErrorReason reason;
        Writer.tell "\n";
        printHelpP spec usageDoc;
        Sys.exit 2
      with Writer.channelHandler stderr
    end

  (* ============================================================= *)
  (* Help *)

  let helpAction () =
    handle printHelp () with Writer.channelHandler stdout;
    Sys.exit 0

  let helpSwitch =
    Switch 'h' [] helpAction
      "Display this list of options"

  let helpKey =
    Key "--help" [] (Unit helpAction)
      "Display this list of options"
end : sig
  (** Effects that may modify environment of parsing engine *)
  effect this : effrow -> effect

  (** Get current specification of arguments *)
  val getSpec : Unit ->[this r] List (ArgSpec [this r|r])

  (** Set specification of arguments.
    Typical use of that function is to support command-arguments like:
    $ command subcommand subcommand-specific-options

    Warning: cheking if mandatory argument were hit will be done on a new
    specification (according to new Hit flags). If you want to force checking
    for mandatory arguments call checkMandatory before, or copy mandatory
    arguments from old specification (get by getSpec) to new specification.
  *)
  val setSpec : List (ArgSpec [this r|r]) ->[this r] Unit

  (** Get list of the reamining arguments. Current argument is not present
    in the list *)
  val getRest : Unit ->[this r] List String

  (** Set list of the reamining arguments *)
  val setRest : List String ->[this r] Unit

  (** Expand list of remaining arguments by putting new arguments on the front
    of list *)
  val expand : List String ->[this r] Unit

  (** Get usage doc *)
  val getUsageDoc : Unit ->[this r] UsageDoc

  (** Set usage doc *)
  val setUsageDoc : UsageDoc ->[this r] Unit

  (** Check if all mandatory options were hit *)
  val checkMandatory : Unit ->[this r] Unit

  (** Parse given arguments according to given specification. *)
  val parseArgs : List (ArgSpec [this r|r]) -> UsageDoc -> List String
    ->[Error [this r|r]|r] Unit

  (** Parse command line arguments according to given specification.
    On error prints program usage with list of options and exits the program
    with exit code 2. *)
  val parse : List (ArgSpec [this [IO|r],IO|r]) -> UsageDoc -> [IO|r] Unit

  (** Prints ErrorReason using Writer effect. *)
  val printErrorReason : ErrorReason ->[Writer String] Unit

  (** Prints ArgSpec using Writer effect. *)
  val printArgSpec : ArgSpec r ->[Writer String] Unit

  (** Prints help for given specification and usage using Writer effect. *)
  val printHelpP : List (ArgSpec r) -> UsageDoc ->[Writer String] Unit

  (** Prints help using Writer effect. *)
  val printHelp : Unit ->[Writer String,this r] Unit

  (** Standard help switch *)
  val helpSwitch : ArgSpec [this [IO,r1],IO|r2]
  (** Standard help key *)
  val helpKey    : ArgSpec [this [IO,r1],IO|r2]
end
