{
open Token
open Grammar
}

(* ========================================================================= *)
(** Grammar file *)
!file:
| preambleCode_opt symbolDefs EOF {
    { preambleCode = preambleCode_opt
    ; symbols      = symbolDefs
    }
  }
;

preambleCode_opt:
| (* empty *) { ""   }
| code:CODE   { code }
;

symbolDefs:
| (* empty *)       { SymMap.empty }
| symbolDefs symbol {
    if SymMap.mem symbol.sName symbolDefs then
      Errors.symbol_redefinition symbol.sName
    else
      SymMap.add symbol.sName symbol symbolDefs
  }
;

(* ========================================================================= *)
(** Symbol definition *)
symbol:
| initIndicator name:LID COLON bar_opt productionList SEMICOLON {
    { sName     = name
    ; sInit     = initIndicator
    ; sProducts = productionList
    }
  }
;

initIndicator:
| (* empty *) { False }
| BANG        { True  }
;

bar_opt:
| (* empty *) { () }
| BAR         { () }
;

productionList:
| p:production                       { [ p ]   }
| p:production BAR ps:productionList { p :: ps }
;

(* ========================================================================= *)
(** Production *)
production:
| argList code:CODE {
    { pArgs = argList
    ; pCode = code
    }
  }
;

argList:
| (* empty *) { []             }
| arg argList { arg :: argList }
;

arg:
| tok:UID                { AnonToken tok     }
| name:LID COLON tok:UID { ArgToken name tok }
| name:LID COLON sym:LID { NTerm name sym    }
| sym:LID                { NTerm sym  sym    }
;
