open Unify

module S =
struct
  type this = Int
  module SI = List.Search(Int)
  let assocH (type E1 E2 V X) (c : Unit -> [Assoc Int E1 V, E1, E2] X) =
    handle c () with
    | assoc x new / r => fn xs =>
      handle SI.assoc x xs with
      | not_found () =>
        let v = new ()
        in r v ((x, v) :: xs)
      | return v => r v xs
      end
    | return v => fn xs => v, xs
    end []
  let print n = Int.toString n
end

module Sig =
struct

  data this T = SBool | SProd of T, T | SArrow of T, T

  let fmap f x =
    match x with
    | SBool      => SBool
    | SProd  x y => SProd  (f x) (f y)
    | SArrow x y => SArrow (f x) (f y)
    end

  let zipWith f x1 x2 =
    match x1, x2 with
    | SBool, SBool => SBool
    | SBool, _     => error (x1, x2)
    | SProd a1 b1, SProd a2 b2 =>
      SProd (f a1 a2) (f b1 b2)
    | SProd _ _, _ => error (x1, x2)
    | SArrow a1 b1, SArrow a2 b2 =>
      SArrow (f a1 a2) (f b1 b2)
    | SArrow _ _, _ => error (x1, x2)
    end

  let print t p =
    let parens s = "(" ++ s ++ ")" in
    match t with
    | SBool        => "bool"
    | SProd  t1 t2 => parens (p t1 ++ " × " ++ p t2)
    | SArrow t1 t2 => parens (p t1 ++ " → " ++ p t2)
    end

end

let rec stringOfTerm t =
  match t with
  | Var n => "[" ++ stringOfInt n ++ "]"
  | Term s => Sig.print s stringOfTerm
end

module U = Unify(Sig)(S)

let printify t1 t2 =
  printStr (stringOfTerm t1 ++ " ≃? " ++ stringOfTerm t2 ++ ": ");
  handle
    let s =
      handle
        let s = U.convert t1
        in U.unify s (U.convert t2); s
      with U.sealH $>
        assertNoError "Phase distinction in Unify enforced as an invariant"
    let tr = U.project s
    in printStr (stringOfTerm tr ++ "\n")
  with
    U.unifyH $>
    handle
    | error m =>
      match m with
      | UECirc => printStr "Circular dependency!\n"
      | UEMismatch t1 t2 => printStr ("Structure mismatch: " ++ Sig.print t1 (fn _ => "?") ++ " and " ++ Sig.print t2 (fn _ => "?") ++  " are incomatible!\n")
      end
    end

open type Sig
let bool = Term SBool
let ( * ) t1 t2 = Term (SProd t1 t2)
let (:->) t1 t2 = Term (SArrow t1 t2)

let x = Var 0
let y = Var 1

let _ = printify bool bool
let _ = printify bool x
let _ = printify bool (bool * x)
let _ = printify (x :-> y) (y :-> bool)
let _ = printify (x :-> y) x
