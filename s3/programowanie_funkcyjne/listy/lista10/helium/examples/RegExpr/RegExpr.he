(** A simple matcher for regular expressions *)

data rec RE A = Eps | Lit of A | Cat of RE A, RE A | Or of RE A, RE A | Star of RE A

(* equality "type-class" as an effect *)
effect Equal A = { equal : A, A => Bool }

effect Reader A =
  { read : Unit => A }

effect NonDet =
  { fail : type A. Unit => A
  ; amb  : Unit => Bool }

(* a local effect, used to check whether progress was made since the
   last mark operation *)
effect Progress =
  { mark : Unit => Unit
  ; set  : Unit => Unit
  ; ask  : Unit => Bool }

(* the core of the matching algorithm. If a literal is consumed, we
   signal that progress has been made through the set operation,
   otherwise we signal a failure.  Concatenation calls the matcher
   sequentially, while the alternative is handled through the
   nondeterministic choice operation. The Kleene star is treated as
   its standard expansion, but with the proviso that there has to be
   progress made between unfoldings --- otherwise the failure
   operation is called. *)
let rec matchRE exp =
  match exp with
  | Eps => ()
  | Lit c =>
    if equal c (read ())
    then set ()
    else fail ()
  | Cat e1 e2 => matchRE e1; matchRE e2
  | Or e1 e2 =>
    if amb ()
    then matchRE e1
    else matchRE e2
  | Star e =>
    if amb () then ()
    else (
      mark ();
      matchRE e;
      if ask () then matchRE exp
      else fail ())
  end

(* Here we handle the Reader and Progress effects. Progress is handled
   as a single-bit state, while Reader actually consumes the initial
   list. Note that the return clause checks if the entire string was
   matched, and that there is still nondeterminism present: how that
   is handled is up to the client. *)
let runMatcher e xs =
  handle
    handle matchRE e with
    | return () => fn _ => ()
    | mark ()   => fn _ => resume () False
    | set ()    => fn _ => resume () True
    | ask ()    => fn b => resume b  b
    end False
  with
  | read () => fn xs =>
    match xs with
    | []      => fail ()
    | x :: xs => resume x xs
    end
  | return () => fn xs =>
    match xs with
    | [] => ()
    | _  => fail ()
    end
  end xs

(* Simply check for the match. Note that if the first resumption
   succeeds, the second will not get called. *)
let matches e xs =
  handle runMatcher e xs with
  | return () => True
  | fail ()   => False
  | amb ()    => resume True || resume False
  end

(* Count the number of matches by giving a different handler to the
   NonDet effect *)
let countMatches e xs =
  handle runMatcher e xs with
  | return () => 1
  | fail ()   => 0
  | amb ()    => resume True + resume False
  end

let stringOfBool b =
  if b then "True" else "False"

let prints e xs =
  handle printStr (stringOfBool (matches e xs) ++ "\n") with
  | equal x y => resume (x = y)
  end

let printc e xs =
  handle printInt (countMatches e xs) with
  | equal x y => resume (x = y)
  end

(* Infix syntax for alternative and concatenation *)
let (:|) r1 r2 = Or r1 r2
let (:*) r1 r2 = Cat r1 r2

(* Some simple tests *)
let _ = prints (Lit 1 :| (Lit 2 :* Lit 2)) [2, 2]
let _ = prints (Lit 1 :| (Lit 2 :* Lit 2)) [1, 2]
let _ = prints (Lit 1 :| (Lit 2 :* Lit 2)) [2, 2, 1]
let _ = prints (Star (Lit 1 :| (Lit 2 :* Lit 2))) [2, 2, 1]
let _ = prints (Star (Lit 2 :| (Lit 2 :* Lit 2))) [1, 2]


let _ = printc (Lit 1 :| (Lit 2 :* Lit 2)) [2, 2]
let _ = printc (Lit 1 :| (Lit 2 :* Lit 2)) [1, 2]
let _ = printc (Lit 1 :| (Lit 2 :* Lit 2)) [2, 2, 1]
let _ = printc (Star (Lit 1 :| (Lit 2 :* Lit 2))) [2, 2, 1]
let _ = printc (Star (Lit 2 :| (Lit 2 :* Lit 2))) [2, 2]
