open LR0Automaton
module G = Grammar

effect Emit =
  { emit : String => Unit }

effect StateEnv =
  { get_link : String => Link
  ; get_args : Int    => List Arg
  }

let productName id =
  "__action_" ++ stringOfInt id

let stateName id =
  "__state_" ++ stringOfInt id

let collectTokenLinks links =
  handle
    ArgMap.iter (fn arg link =>
        match arg with
        | AnonToken _ => Writer.tell (arg, link)
        | ArgToken  _ => Writer.tell (arg, link)
        | NTerm _     => ()
        end
      ) links
  with Writer.listHandler

let genGrammarArg arg =
  match arg with
  | G.AnonToken  _    => ()
  | G.ArgToken name _ => emit " "; emit name
  | G.NTerm    name _ => emit " "; emit name
  end

let genArg i arg =
  match arg with
  | AnonToken _ => ()
  | ArgToken  _ =>
    emit " a";
    emit (stringOfInt i)
  | NTerm _ =>
    emit " a";
    emit (stringOfInt i)
  end

let genContArg i =
  emit " k";
  emit (stringOfInt i)

let genProduction prod =
  emit "let ";
  emit (productName prod.pId);
  List.iter genGrammarArg (List.rev prod.pArgs); (* TODO reverse all arguments (except that) *)
  emit " () =";
  emit prod.pCode;
  emit "\n"

let genLinkCode extraArg link =
  emit (stateName link.lState);
  extraArg ();
  List.iteri genArg (get_args (link.lArgN - 1));
  List.iter genContArg link.lConts;
  emit "\n"

let genClosureCont kw contN i nTerm =
  emit "  ";
  emit kw;
  genContArg (contN + i);
  emit " x = ";
  let link = get_link nTerm in
  genLinkCode (fn () => emit " x") link

let genTokenLink accept (arg, link) =
  match arg with
  | AnonToken tok =>
    emit "  | ";
    emit tok;
    emit " =>";
    accept ();
    genLinkCode (fn () => ()) link
  | ArgToken tok =>
    emit "  | ";
    emit tok;
    emit " x =>";
    accept ();
    genLinkCode (fn () => emit " x") link
  | _ => ()
  end

let genReduceRule rr =
  emit "  ";
  genContArg rr.rrCont;
  emit " (";
  emit (productName rr.rrProduct);
  List.iteri genArg (get_args rr.rrArgN);
  emit " ())\n"

let genAcceptToken () =
  emit "\n    let _ = Parsing.get_token () in\n    "

let genState state =
  handle
    emit "and ";
    emit (stateName state.sId);
    List.iteri genArg state.sArgs;
    List.iteri (fn i _ => genContArg i) state.sKernel;
    emit " =\n";
    let contN = List.length state.sKernel in
    match state.sClosure with
    | [] => ()
    | nTerm :: closure =>
      genClosureCont "let rec" contN 0 nTerm;
      List.iteri (genClosureCont "and" (contN + 1)) closure;
      emit "  in\n"
    end;
    let tokenLinks = collectTokenLinks state.sLinks in
    match state.sReduceRules, tokenLinks with
    | [], _ =>
      emit "  match Parsing.get_token () with\n";
      List.iter (genTokenLink (fn () => emit " ")) tokenLinks;
      emit "  | _ => Parsing.parse_error ()\n";
      emit "  end\n"
    | rr :: _, [] => genReduceRule rr
    | rr :: _, _  =>
      emit "  match Parsing.lookahead () with\n";
      List.iter (genTokenLink genAcceptToken) tokenLinks;
      emit "  | _ =>\n";
      emit "    let _ = Parsing.rollback () in\n";
      emit "  "; genReduceRule rr;
      emit "  end\n"
    end
  with
  | get_link nTerm / res =>
    handle ArgMap.find (NTerm nTerm) state.sLinks with
    | return link     => res link
    | Map.not_found _ => Errors.assertion_failed "Link not found."
    end
  | get_args n => resume (List.take n state.sArgs)
  end

let genInitState init =
  emit "let ";
  emit init.isNTerm;
  emit " () = ";
  emit (stateName init.isState);
  emit " (fn x => x)\n"

let genParser automaton =
  emit automaton.preambleCode;
  emit "\n(* ======================================== *)\n";
  emit "(* Semantic actions *)\n";
  IntMap.iter (fn _ => genProduction) automaton.products;
  emit "\n(* ======================================== *)\n";
  emit "(* States *)\n";
  emit "let rec __state_dummy k = k\n";
  IntMap.iter (fn _ => genState) automaton.states;
  emit "\n(* ======================================== *)\n";
  emit "(* Initial rules *)\n";
  List.iter genInitState automaton.initStates

let printCode automaton =
  handle genParser automaton with
  | return () => fn buf =>
    printStr (StringBuf.contents buf)
  | emit code => fn buf =>
    resume () (StringBuf.addString buf code)
  end StringBuf.empty
