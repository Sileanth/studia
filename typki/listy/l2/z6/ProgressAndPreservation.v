(** Here, we prove progress and type preservation.
  * For substitution lemma refer to Typing module. *)

Require Import Utf8.
Require Import Syntax SemanticsSOS Typing.

(** Inversion lemma about closed values of an arrow type *)
Lemma arrow_value_inv {Γ : env Empty_set} {v : value _} {τ₁ τ₂ : type} :
  T[ Γ ⊢ v ∷ t_arrow τ₁ τ₂ ] →
  ∃ e, v = v_lam τ₁ e ∧ T[ env_ext Γ τ₁ ⊢ e ∷ τ₂ ].
Proof.
  inversion 1.
  + (* impossible case *)
    match goal with [ x : Empty_set |- _ ] => destruct x end.
  + eauto.
Qed.

Theorem progress (e : expr _) (τ : type) :
  T[ env_empty ⊢ e ∷ τ ] →
  (∃ v : value _, e = v) ∨ (∃ e', red e e').
Proof.
  (* Since the type of potentially free variables is an irregular parameter
   * (may change on recursive call) of the typing relation, the induction
   * scheme generated by Coq requires to prove the propery for all these sets.
   * Therefore we use Henry Ford induction here: we prove the property for any
   * set A so long as it is Empty_set. We start with permuting the assumption
   * to setup scene for the induction *)
  generalize env_empty as Γ; remember Empty_set as A.
  intros Γ Htyping; generalize HeqA; clear HeqA.
  (* And now, we can proceed by induction on the typing derivation *)
  induction Htyping as [ | | | A Γ e₁ e₂ τ₂ τ₁ Htyping1 IH1 ? IH2 ];
    intro Heq; subst.
  + left; eexists; reflexivity.
  + destruct x. (* impossible case *)
  + left; eexists; reflexivity.
  + right.
    (* we have three cases: *)
    destruct IH1 as [ [ v₁ ? ] | [ e₁' ? ] ];
      [ reflexivity
      | destruct IH2 as [ [ v₂ ? ] | [ e₂' ? ] ]; trivial | ].
    - subst.
      destruct (arrow_value_inv Htyping1) as [ e [ Hv He ] ].
      subst; eexists; apply red_beta.
    - subst; eexists; apply red_app2; eassumption.
    - eexists; apply red_app1; eassumption.
Qed.

(* ========================================================================= *)

Theorem preservation {A : Set} (Γ : env A) e e' τ :
  red e e' →
  T[ Γ ⊢ e ∷ τ ] → T[ Γ ⊢ e' ∷ τ ].
Proof.
  (* We need slightly generalize the theorem, to say: foeach τ ... *)
  intro Hred; generalize τ; clear τ.
  (* And proceed by induction on the derivation of reduction judgement *)
  induction Hred; intro τ.
  + intro H. inversion H. subst. inversion H2. subst.
    eapply typing_subst; eauto.
  + inversion 1; subst; econstructor; eauto.
  + inversion 1; subst; econstructor; eauto.
Qed.

Definition type_eq_dec : forall (x y : type), { x = y } + { x <> y }.
Proof.
  decide equality.
Defined.

Fixpoint eq_types (x y : type) : bool :=
  match (pair x y) with
  | pair t_unit t_unit => true
  | pair (t_arrow t1 t2) (t_arrow t3 t4) => eq_types t1 t3 && eq_types t2 t4
  | _ => false
  end.

Lemma eq_types_proof : forall (x y : type), x = y <-> eq_types x y = true.
Proof.
  induction x.
  - intro y. split.
    + intro H. destruct H. reflexivity.
    + destruct y; cbn.
      * auto.
      * inversion 1. (* WTF *)
  - intro y. split.
    + intro H. rewrite <- H. cbn.
      assert (H1 : eq_types x1 x1 = true). apply IHx1; reflexivity.
      assert (H2 : eq_types x2 x2 = true). apply IHx2; reflexivity.
      rewrite H1. rewrite H2. reflexivity.
    + intro H. destruct y.
      * cbn in H. inversion H.
      * cbn in H.
        assert (H1 : x1 = y1). apply IHx1. destruct (eq_types x1 y1). auto. inversion H.
        assert (H2 : x2 = y2). apply IHx2. destruct (eq_types x2 y2). auto. inversion H.
        destruct (eq_types x1 y1); auto.
        rewrite H1. rewrite H2. reflexivity.
Qed.


Fixpoint infer_type (A : Set) (Γ : env A) (e : expr A): option type :=
  match e with
  | e_app e1 e2 =>
    match pair (infer_type A Γ e1) (infer_type A Γ e2) with
    | pair (Some (t_arrow t1 t2)) (Some t3) => if eq_types t1 t3 then Some t2 else None
    | _ => None
    end
  | e_value v => infer_value_type A Γ v
  end 
  with infer_value_type (A : Set) (Γ : env A) (v : value A) : option type :=
    match v with
    | v_var x => Some (Γ x) 
    | v_lam t e => match infer_type (inc A) (env_ext Γ t) e with
      | Some t2 => Some (t_arrow t t2)
      | _ => None
        end
    | v_unit => Some t_unit
    end.

Fixpoint ev_proof (P : forall A, expr A -> Prop)
                  (Papp : forall A e1 e2, P A e1 -> P A e2 -> P A (e_app e1 e2))
                  (Pvar : forall A x, P A (e_value (v_var x)))
                  (Plam : forall A (e : expr (inc A)) t, P (inc A) e -> P A (e_value (v_lam t e)))
                  (Punt : forall A, P A (e_value v_unit))
                  A (e : expr A) : P A e :=
  match e with
  | e_app e1 e2         => Papp A e1 e2 (ev_proof P Papp Pvar Plam Punt A e1)
                                        (ev_proof P Papp Pvar Plam Punt A e2)
  | e_value (v_var x)   => Pvar A x
  | e_value (v_lam t e) => Plam A e t (ev_proof P Papp Pvar Plam Punt (inc A) e)
  | e_value v_unit      => Punt A
  end.




Theorem infer_fn : forall (A : Set) (Γ : env A) e t,
  infer_type A Γ e = Some t <-> T[ Γ ⊢ e ∷ t ].
Proof.
  split; cycle 1.
  - intro H. induction H; auto.
    + cbn. rewrite IHtyping. easy.
    + cbn. rewrite IHtyping1. rewrite IHtyping2.
      assert (H2 : eq_types τ₂ τ₂ = true). apply eq_types_proof. auto.
      rewrite H2. auto.
  - generalize t. clear t. induction e using ev_proof.
    * intros t h. 
      cbn in h.
      assert (A1 : exists t1 t2, infer_type A Γ e1 = Some (t_arrow t1 t2)). 
      {
        destruct (infer_type A Γ e1). destruct t0.
        - inversion h.
        - exists t0_1. exists t0_2. reflexivity.
        - inversion h.

      }
      destruct A1 as [ t1 [t2 H1]].
      assert (A2 : exists t3, infer_type A Γ e2 = Some t3). {
        rewrite H1 in h.
        destruct (infer_type A Γ e2). destruct (eq_types t1 t0).
        exists t0. reflexivity.
        exists t0. reflexivity.
        inversion h.
      }
      destruct A2 as [ t3 H2].
      assert (A4 : t = t2).  {
        rewrite H1 in h.
        rewrite H2 in h.
        destruct (eq_types t1 t3).
        - inversion h. reflexivity.
        - inversion h.
      }
      assert (A3 : eq_types t1 t3 = true). {
        rewrite H1 in h.
        rewrite H2 in h.
        destruct (eq_types t1 t3).
        - reflexivity.
        - inversion h.
      }
      apply eq_types_proof in A3. subst.
      econstructor. 
      apply IHe1 in H1. apply IHe2 in H2. eauto. eauto.
    * intros t h. cbn in h. inversion h.
      constructor.
    * intros t0 h. cbn in h.
      assert (A1 : exists t2, infer_type (inc A) (env_ext Γ t) e = Some t2). {
        destruct (infer_type (inc A) (env_ext Γ t) e).
        - exists t1. reflexivity.
        - inversion h.
      }
      destruct A1 as [ t2 h1].
      assert (A2 : t0 = t_arrow t t2).  {
        destruct (infer_type (inc A) (env_ext Γ t) e).
        inversion h.
        inversion h1.
        reflexivity.
        inversion h.
      }
      apply IHe in h1. 
      subst.
      apply T_Lam. 
      apply h1.
    * intros t h. cbn in h. inversion h. apply T_Unit.
    Qed.
